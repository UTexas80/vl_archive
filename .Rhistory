d4 <- d3 - (implied_volatility * sqrt(days_to_expiration))
d5 <- (log(current_stock_price / upper_put_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d6 <- d5 - (implied_volatility * sqrt(days_to_expiration))
d7 <- (log(current_stock_price / lower_put_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d8 <- d7 - (implied_volatility * sqrt(days_to_expiration))
# Calculate the probabilities using the cumulative distribution function (CDF)
prob_profit <- pnorm(d2) - pnorm(d1) - pnorm(d6) + pnorm(d5)
# Print the probability of profit
print(prob_profit)
library(quantmod)
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 26.1
risk_free_rate <- 0.0543
days_to_expiration <- 37
# Calculate the required inputs for the Black-Scholes model
d1 <- (log(current_stock_price / lower_call_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d2 <- d1 - (implied_volatility * sqrt(days_to_expiration))
d3 <- (log(current_stock_price / upper_call_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d4 <- d3 - (implied_volatility * sqrt(days_to_expiration))
d5 <- (log(current_stock_price / upper_put_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d6 <- d5 - (implied_volatility * sqrt(days_to_expiration))
d7 <- (log(current_stock_price / lower_put_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d8 <- d7 - (implied_volatility * sqrt(days_to_expiration))
# Calculate the probabilities using the cumulative distribution function (CDF)
prob_profit <- pnorm(d2) - pnorm(d1) - pnorm(d6) + pnorm(d5)
# Print the probability of profit
print(prob_profit)
library(quantmod)
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 37
# Calculate the required inputs for the Black-Scholes model
d1 <- (log(current_stock_price / lower_call_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d2 <- d1 - (implied_volatility * sqrt(days_to_expiration))
d3 <- (log(current_stock_price / upper_call_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d4 <- d3 - (implied_volatility * sqrt(days_to_expiration))
d5 <- (log(current_stock_price / upper_put_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d6 <- d5 - (implied_volatility * sqrt(days_to_expiration))
d7 <- (log(current_stock_price / lower_put_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d8 <- d7 - (implied_volatility * sqrt(days_to_expiration))
# Calculate the probabilities using the cumulative distribution function (CDF)
prob_profit <- pnorm(d2) - pnorm(d1) - pnorm(d6) + pnorm(d5)
# Print the probability of profit
print(prob_profit)
dt[, sigma := vol * sqrt(T)]
S0  <- 90.49
vol <- 0.261
r   <- 0.0549
T   <- 37/252
P   <- 7.67
# ------------------------------------------------------------------------------
# Create a data table with the inputs
dt <- data.table(S0 = S0, vol = vol, r = r, T = T)
# Calculate the annualized standard deviation
dt[, sigma := vol * sqrt(T)]
BE_lower <- 90 - P
BE_upper <- 95 + P
dt[, prob :=
stats::pnorm((log(BE_upper/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T)) -
stats::pnorm((log(BE_lower/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T))]
dt
S0  <- 90.49
vol <- 0.261
r   <- 0.0549
T   <- 17/252
P   <- 7.67
# ------------------------------------------------------------------------------
# Create a data table with the inputs
dt <- data.table(S0 = S0, vol = vol, r = r, T = T)
# Calculate the annualized standard deviation
dt[, sigma := vol * sqrt(T)]
BE_lower <- 90 - P
BE_upper <- 95 + P
dt[, prob :=
stats::pnorm((log(BE_upper/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T)) -
stats::pnorm((log(BE_lower/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T))]
dt
S0  <- 90.49
vol <- 0.261
r   <- 0.0549
T   <- 1/252
P   <- 7.67
# ------------------------------------------------------------------------------
# Create a data table with the inputs
dt <- data.table(S0 = S0, vol = vol, r = r, T = T)
# Calculate the annualized standard deviation
dt[, sigma := vol * sqrt(T)]
BE_lower <- 90 - P
BE_upper <- 95 + P
dt[, prob :=
stats::pnorm((log(BE_upper/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T)) -
stats::pnorm((log(BE_lower/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T))]
dt
S0  <- 90.49
vol <- 0.261
r   <- 0.0549
T   <- 111/252
P   <- 7.67
# ------------------------------------------------------------------------------
# Create a data table with the inputs
dt <- data.table(S0 = S0, vol = vol, r = r, T = T)
# Calculate the annualized standard deviation
dt[, sigma := vol * sqrt(T)]
BE_lower <- 90 - P
BE_upper <- 95 + P
dt[, prob :=
stats::pnorm((log(BE_upper/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T)) -
stats::pnorm((log(BE_lower/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T))]
dt
S0  <- 90.49
vol <- 26.1
r   <- 0.0549
T   <- 36/252
P   <- 7.67
# ------------------------------------------------------------------------------
# Create a data table with the inputs
dt <- data.table(S0 = S0, vol = vol, r = r, T = T)
# Calculate the annualized standard deviation
dt[, sigma := vol * sqrt(T)]
BE_lower <- 90 - P
BE_upper <- 95 + P
dt[, prob :=
stats::pnorm((log(BE_upper/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T)) -
stats::pnorm((log(BE_lower/S0) + (r + (sigma ^ 2)/2) * T) / sigma * base::sqrt(T))]
dt
library(quantmod)
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
# Calculate the required inputs for the Black-Scholes model
d1 <- (log(current_stock_price / lower_call_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d2 <- d1 - (implied_volatility * sqrt(days_to_expiration))
d3 <- (log(current_stock_price / upper_call_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d4 <- d3 - (implied_volatility * sqrt(days_to_expiration))
d5 <- (log(current_stock_price / upper_put_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d6 <- d5 - (implied_volatility * sqrt(days_to_expiration))
d7 <- (log(current_stock_price / lower_put_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d8 <- d7 - (implied_volatility * sqrt(days_to_expiration))
# Calculate the probabilities using the cumulative distribution function (CDF)
prob_profit <- pnorm(d2) - pnorm(d1) - pnorm(d6) + pnorm(d5)
# Print the probability of profit
print(prob_profit)
d1
d2
d3
d6
d5
r   <- 0.0549
library(quantmod)
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
# Calculate the required inputs for the Black-Scholes model
d1 <- (log(current_stock_price / lower_call_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d2 <- d1 - (implied_volatility * sqrt(days_to_expiration))
d3 <- (log(current_stock_price / upper_call_strike) + (risk_free_rate + (implied_volatility^2) / 2) * days_to_expiration) / (implied_volatility * sqrt(days_to_expiration))
d4 <- d3 - (implied_volatility * sqrt(days_to_expiration))
# Calculate the probability of profit within the iron condor range
prob_profit <- pnorm(d2) - pnorm(d1) - (pnorm(d4) - pnorm(d3))
# Print the probability of profit
print(prob_profit)
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
# Define the number of steps for the binomial model
n_steps <- 100
# Compute the step size
step_size <- days_to_expiration / n_steps
# Define the up and down factors for the binomial model
up_factor <- exp(implied_volatility * sqrt(step_size))
down_factor <- 1 / up_factor
# Compute the risk-neutral probabilities
risk_neutral_prob_up <- (exp(risk_free_rate * step_size) - down_factor) / (up_factor - down_factor)
risk_neutral_prob_down <- 1 - risk_neutral_prob_up
# Initialize variables for tracking probabilities
prob_profit <- 0
prob_loss <- 0
# Loop through the stock price scenarios
for (i in 0:n_steps) {
# Compute the stock price at each step
stock_price <- current_stock_price * (up_factor^(n_steps - i)) * (down_factor^i)
# Check if the stock price is within the profitable range
if (stock_price >= lower_put_strike && stock_price <= upper_call_strike) {
prob_profit <- prob_profit + choose(n_steps, i) * (risk_neutral_prob_up^i) * (risk_neutral_prob_down^(n_steps - i))
} else {
prob_loss <- prob_loss + choose(n_steps, i) * (risk_neutral_prob_up^i) * (risk_neutral_prob_down^(n_steps - i))
}
# Calculate the probability of profit
probability_of_profit <- prob_profit / (prob_profit + prob_loss)
# Print the probability of profit
print(probability_of_profit)
# Define the parameters
current_stock_price <- 90.49                                                    # dx_condor_key[,2]
upper_call_strike   <- 100                                                      # dx_condor_key[id_strike == 4, 5]
lower_call_strike   <- 90                                                       # dx_condor_key[id_strike == 2, 5]
lower_put_strike    <- 85                                                       # dx_condor_key[id_strike == 1, 5]
upper_put_strike    <- 95                                                       # dx_condor_key[id_strike == 3, 5]
net_credit          <- 7.35                                                     # dx_condor_roi[, 2]
num_simulations     <- 10000
implied_volatility  <- 0.216                                                    # dx_condor_pop[,4]/100
risk_free_rate      <- 0.0543                                                   # dx_int[,1]
days_to_expiration  <- 37
# Calculate time to expiration in years
time_to_expiration  <- days_to_expiration / 365                                 # dx_condor_pop[1,8]
# Generate random stock price scenarios
set.seed(123) # For reproducibility
z <- rnorm(num_simulations)
simulated_stock_prices <- current_stock_price * exp((risk_free_rate - 0.5 * implied_volatility^2) * time_to_expiration + implied_volatility * sqrt(time_to_expiration) * z)
# Calculate the payoff for each scenario
payoffs <- numeric(num_simulations)
for (i in 1:num_simulations) {
payoff <- ifelse(
simulated_stock_prices[i] < lower_put_strike,
net_credit - (lower_put_strike - simulated_stock_prices[i]),
ifelse(
simulated_stock_prices[i] >= lower_put_strike & simulated_stock_prices[i] <= upper_put_strike,
net_credit,
ifelse(
simulated_stock_prices[i] > upper_put_strike & simulated_stock_prices[i] < lower_call_strike,
0,
ifelse(
simulated_stock_prices[i] >= lower_call_strike & simulated_stock_prices[i] <= upper_call_strike,
net_credit,
net_credit - (simulated_stock_prices[i] - upper_call_strike)
)
payoffs[i] <- payoff
}
# Calculate the probability of profitability
probability_of_profit <- sum(payoffs > 0) / num_simulations
# Print the result
cat("Probability of Profitability:", probability_of_profit, "\n")
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(i)]
stock_prices <- rbind(stock_prices, dt)
}
dt
dt$days
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(i)]
stock_prices <- rbind(stock_prices, dt)
}
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(i)]
stock_prices <- rbind(stock_prices, dt)
}
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(i)]
stock_prices <- rbind(stock_prices, dt)
}
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(i)]
stock_prices <- rbind(stock_prices, dt)
}
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(I)]
stock_prices <- rbind(stock_prices, dt)
}
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
stock_prices <- rbind(stock_prices, dt)
}
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
stock_prices <- rbind(stock_prices, dt)
}
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(i)]
stock_prices <- rbind(stock_prices, dt)
}
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
simulated_stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(i)]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
simulated_stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days)))), by = .(i)]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
simulated_stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
# Define the necessary parameters
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 37
n_simulations <- 10  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
simulated_stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
prob_profit <- sum(simulated_stock_prices[, any(stock_price >= lower_put_strike) & any(stock_price <= upper_call_strike)]) / n_simulations
# Print the probability of profit
print(prob_profit)
n_simulations <- 1000
simulated_stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
prob_profit <- sum(simulated_stock_prices[, any(stock_price >= lower_put_strike) & any(stock_price <= upper_call_strike)]) / n_simulations
# Print the probability of profit
print(prob_profit)
implied_volatility <- 26.261
risk_free_rate <- 5.0543
implied_volatility <- 26.261
risk_free_rate <- 5.0543
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
simulated_stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
# Calculate the probability of profit
prob_profit <- sum(simulated_stock_prices[, any(stock_price >= lower_put_strike) & any(stock_price <= upper_call_strike)]) / n_simulations
# Print the probability of profit
print(prob_profit)
View(simulated_stock_prices)
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
simulated_stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
current_stock_price <- 90.49
upper_call_strike <- 100
lower_call_strike <- 90
lower_put_strike <- 85
upper_put_strike <- 95
implied_volatility <- 0.261
risk_free_rate <- 0.0543
days_to_expiration <- 39
n_simulations <- 1000  # Number of Monte Carlo simulations
# Set the seed for reproducibility
set.seed(42)
# Simulate stock price scenarios using geometric Brownian motion
simulated_stock_prices <- data.table()
for (i in 1:n_simulations) {
dt <- data.table(days = 0:days_to_expiration)
dt[, stock_price := current_stock_price * exp(cumsum((risk_free_rate - (implied_volatility^2) / 2) * dt$days + implied_volatility * sqrt(dt$days) * rnorm(length(dt$days))))]
simulated_stock_prices <- rbind(simulated_stock_prices, dt)
}
# Calculate the probability of profit
prob_profit <- sum(simulated_stock_prices[, any(stock_price >= lower_put_strike) & any(stock_price <= upper_call_strike)]) / n_simulations
# Print the probability of profit
print(prob_profit)
